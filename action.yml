name: 'Spikybot Code Agent'
description: 'Autonomous coding agent running on GitHub Actions with Codex CLI'
inputs:
  github-token:
    description: 'GitHub Token'
    required: true
  codex-token:
    description: 'Codex Auth Token'
    required: true
runs:
  using: 'composite'
  steps:
    - name: Evaluate trigger conditions
      shell: bash
      env:
        BODY: ${{ github.event.comment.body || github.event.issue.body || github.event.pull_request.body }}
        ASSIGNEES: ${{ toJson(github.event.issue.assignees || github.event.pull_request.assignees) }}
        SENDER: ${{ github.event.sender.login }}
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        bot_login=$(gh api user --jq '.login')
        run=false
        [[ "$BODY" == *"@$bot_login"* ]] && run=true
        [[ "$ASSIGNEES" == *"\"$bot_login\""* ]] && run=true
        [[ "$SENDER" == "$bot_login" ]] && run=false
        echo $bot_login, $BODY, $ASSIGNEES, $SENDER
        echo "run=$run" >>"$GITHUB_ENV"

    - name: Post acknowledgement comment
      if: ${{ env.run && github.event.action != 'edited' }}
      shell: bash
      env:
        NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        b="Thinking... [run](https://github.com/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID)"
        u=$(gh issue comment "${NUMBER}" -R "$GITHUB_REPOSITORY" -b "$b")
        i=${u##*issuecomment-}
        echo "comment_id=$i" >>"$GITHUB_ENV"
        echo "run=false" >>"$GITHUB_ENV"

    - name: Update acknowledgement comment
      if: ${{ env.run && github.event_name == 'issue_comment' && github.event.action == 'edited' }}
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        GITHUB_TOKEN: ${{ inputs.github-token }}
        REPO: ${{ github.repository }}
        TARGET_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
        JOB_NAME: ${{ github.job }}
        RUN_ID: ${{ github.run_id }}
      run: |
        comment=""
        bot=$(gh api user --jq -r '.login' || true)
        if [[ -n "$bot" ]]; then
          comment=$(gh api "repos/${REPO}/issues/${TARGET_NUMBER}/comments" --paginate --jq "map(select(.user.login == \"$bot\")) | last | .id" || true)
          [[ "$comment" == "null" ]] && comment=""
          if [[ -n "$comment" ]]; then
            job_id=$(gh api "repos/${REPO}/actions/runs/${RUN_ID}/jobs" --paginate --jq '.jobs[] | select(.name == "'"${JOB_NAME}"'") | .id' | tail -n1 || true)
            job_url="https://github.com/${REPO}/actions/runs/${RUN_ID}"
            if [[ -n "$job_id" ]]; then
              job_url+="/job/${job_id}"
            fi
            gh api "repos/${REPO}/issues/comments/${comment}" --method PATCH -f body="Thinking... [${JOB_NAME}](${job_url})"
          fi
        fi
        echo "comment=$comment" >>"$GITHUB_ENV"
        echo "run=false" >>"$GITHUB_ENV"

    - name: Checkout repository
      if: ${{ env.run }}
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install Codex CLI
      if: ${{ env.run }}
      shell: bash
      run: |
        npm i -g @openai/codex@latest

    - name: Configure Codex Auth
      if: ${{ env.run }}
      shell: bash
      env:
        CODEX_TOKEN: ${{ inputs.codex-token }}
      run: |
        mkdir -p "$HOME/.codex"
        # CODEX_TOKEN="$(openssl base64 -A -in "$HOME/.codex/auth.json")"
        echo "$CODEX_TOKEN" | base64 -d > "$HOME/.codex/auth.json"

    - name: Execute Codex
      if: ${{ env.run }}
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        GITHUB_TOKEN: ${{ inputs.github-token }}
        REPO_SLUG: ${{ github.repository }}
        ACK_COMMENT_ID: ${{ env.comment }}
        TARGET_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
        PROMPT: |
          ## 0.環境変数
          - コマンド例の中の <variable> は以下の環境変数に手動で置換する
          - event_name=${{ github.event_name }}
          - event_action=${{ github.event.action }}
          - session_number=${{ github.event.issue.number || github.event.pull_request.number }}
          - current_branch=${{ github.ref_name }}
          - github_actor=${{ github.actor }}
          - run_url=https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

          ## 1.準備
          1.1 セッション状況の確認
          - このセッションはGitHub Actionsの上で実行されている
          - あなたは@spikybotというGitHubのアカウントである
          - ユーザーからのプロンプトを元に返答言語を決定する
          - ghコマンドを通じた応答は全て返答言語で行う
          - GitHub Issue/PR本文とコメント履歴を確認
          - $ gh issue view <session_number> --comments
          - 会話履歴であなた(@spikybot)からユーザーの割り込みの場合は過去の指示を考慮する
          - 中断された過去のあなたの作業内容は全て破棄されている
          - ghコマンドを用いたコメント投稿/編集などの書き込みは許可されている（必要に応じて実行する）
          - 認証セットアップ: まだ未ログインの場合は、環境変数のトークンを使って認証する（出力にトークン値は絶対に表示しない）
          - 例: `gh --version && (gh auth status -h github.com || true) && (printenv GH_TOKEN | gh auth login --with-token >/dev/null 2>&1 || true) && gh auth status -h github.com`
          - 複数行の文字列をコマンドに渡すときは `cat <<'EOF' ... EOF` のヒアドキュメントを用いる
          - `event_action` が `assigned` かつ `github.event.assignee.login` が `spikybot` の場合は、最新の本文/コメント（自分以外の投稿）を読み、その内容を受領するコメントを残す。
          - 初回コメントのIDは `ACK_COMMENT_ID` に格納されている。

          1.2 メッセージ分類
          - ユーザーからのプロンプトを元に以下の方針を判断する
          - 応答: ユーザーの問いに即応する。初回応答は実行しない。セクション2.と3.と4.は何も実行しない。即座に5.報告へ移動する。
          - 調査: 読み取り中心。4.保存を行わない。3.実行の後、即座に5.報告へ移動する。
          - 実装: 実際の変更を伴う作業。このワークフローの全てを行う。

          1.3 初回応答(調査と実装の場合に実行)
          - ユーザーにタスクを受け取ったことを報告する
          - コメントのbodyは適宜変更
          - |
            $ gh issue comment <session_number> --body "$(cat <<'EOF'
            考えています...
            [Run #${{ github.run_number }}](<run_url>)
            EOF
            )"
          - ここでコマンドからの応答のissuecommentのidの数字を必ず覚えておく(以下、<comment_id>)。`ACK_COMMENT_ID` がセットされている場合はそれを利用できる。

          ## 2.計画(調査と実装の場合に実行)
          2.1 調査(必要に応じて以下の調査を行う)
          - 関連するソースコードを入念に観察する
          - ビルドツールがある場合はその挙動を確認する
          - ソースコード修正前の時点ではテストがパスしているか確認する
          - 小さなテストパターンや予備実験を実行して試してみる

          2.2 計画立案
          - タスク遂行のプランを深く考えてTODOリストを用いて設計する
          - 大量の処理や大規模な変更、難易度が高い実装は検証可能な小さなタスクに分割する
          - 必要に応じて2.1調査に戻って調査を再開する
          - このタスクの影響範囲についてもこの段階で計画する

          2.3 計画断念の検討
          - 指示の曖昧さやタスクの難易度によってタスクが遂行可能か判断する
          - 遂行不能と判断した場合は即座に5.報告へ移動する
          - 遂行不能の場合は必ず5.報告で代案を募るか、追加の指示を仰ぐ
          - 遂行の確度が低い場合は実際に3.実行を行った後に断念を判断しても良い

          2.4 経過報告
          - 計画が遂行可能と判断の場合は経過報告を行う
          - ここで可能であれば計画で作成したTODOをユーザーに報告する
          - 詳細の文脈は省略しても良い
          - 以下の本文を適宜変更し、初回コメントを `jq -n --arg body ... | gh api ... --method PATCH --input -` で上書きする
          - |
            $ jq -n --arg body $'現在のタスク状況は以下の通りです\n1. ...' '{body:$body}' \
              | gh api repos/${REPO_SLUG}/issues/comments/<comment_id> --method PATCH --input -

          ## 3. 実行(調査と実装の場合に実行)
          3.1 タスク選択
          - TODOリストの中から1件ずつ順番に次に実行するタスクを選択
          - 原則として次に実行可能な1つだけを選択し、複数選択しない

          3.2 タスク実行
          - タスク選択で取り出したタスクの1つのみを実行
          - 調査の場合、Readタスクのみ実行可能(プロジェクト確認、Web検索、環境確認)
          - 実装の場合、必要なコマンドの全てを実行可能(編集、生成、コマンド実行、リファクタ等)
          - ユーザーのプロンプトの指示に忠実に従ってタスクを遂行する
          - タスクの途中か完了したあとで新たに必要なTODOが見つかった場合はTODOに追加する
          - 画像に文字が含まれる場合は以下を徹底する
            - `gh api` などで添付画像の署名付きURLを取得し、`curl -L -o /tmp/<session_number>_image.<ext> <url>` でダウンロードする
            - `view_image` などの手段で画像を開き、あなた自身が目視で内容を確認する
            - OCRや画像解析ツールは使用禁止

          3.3 エラーハンドリング
          - エラーの場合とは、指示が曖昧な点、自力解決不能なエラー、実装困難なタスクが発見された場合
          - エラーの場合に限り、以下を実行する
          - 3.実行を終了する。残りのタスクを実行しない
          - ユーザーがデバッグを継続するための追加情報の収集は可能
          - 4.保存に移動し、現在の状況を新規ブランチに保存する
          - 5.報告では現在の状況と完了済みタスク、残りのタスクについても説明する
          - エラーログや質問内容はできるだけ加工せずそのまま報告に含める

          3.4 経過報告
          - 現在の状況を初回応答のコメントを上書き編集する形で報告を行う
          - |
            $ jq -n --arg body $'現在のタスク状況は以下の通りです\n1. ...' '{body:$body}' \
              | gh api repos/${REPO_SLUG}/issues/comments/<comment_id> --method PATCH --input -
          - 経過報告はタスクを1つ完了するか失敗する毎に上書き編集して更新する
          - この際に、過去の完了済みタスクが見えなくならないように、2.4の経過報告の文章を適宜編集する形を取る

          3.5 タスク実行の反復
          - タスクが1つ正常完了した場合、3.1に戻って次のタスク選択を行う
          - 全てのタスクが完了するまで、3.1~3.4を順番に反復する

          ## 4. 保存(実装の場合のみ実行)
          4.1 ブランチの新規作成
          - 現在のブランチ名を確認
          - 現在のevent_name=${{ github.event_name }}がissuesの場合は新規ブランチを作成
          - ブランチ名は必ず"spikybot/xxxxxx"とする。ここでxxxxxxはこのタスクの簡潔な説明
          - 現在のevent_name=${{ github.event_name }}がpull_requestの場合はこのブランチをそのまま使う
          - ただしこのブランチ名が明らかに不適切な場合やPRの内容にそぐわない場合は新規ブランチ作成

          4.2 コミット
          - 現在の変更済みファイル一覧などを確認
          - 変更された各ファイルに対して個別にgit add filenameを行う
          - 危険なオプション(git add ., git add -A, --all)は禁止
          - 多くのプロジェクトで.gitignoreは採用されていない可能性がある
          - 一時ファイル、ゴミファイル、ビルド結果、関連のないファイルの追加を避ける
          - もう一度状況を確認し、問題がなければコミットを行う

          4.2 プッシュ(実装の場合のみ実行)
          - 現在のコミットをプッシュする

          4.3 プルリクエストの作成/更新(実装の場合のみ実行)
          - 条件: event_name=${{ github.event_name }}が'issues'かつ新規実装やファイル変更がある場合のみ新規PR
          - 条件: event_name=${{ github.event_name }}が'pull_request'の場合は新規PR禁止、既存PRへのcommit&pushのみ
          - タイトル: セッション番号と作業内容を含める(例: "#123 XXX修正")
          - 説明: 目的と変更内容を記載
          - Issue完了時: PRの説明文末尾に 'close #<session_number>'と記述
          - ブランチ名が"spikybot/xxxxxx"の場合は以下の通り
          - |
            gh pr create --base "spikybot/xxxxxx" --title "#123 Add new feature" --body "$(cat <<'EOF'
            This adds a new feature.
            説明...
            説明...
            EOF
            )"

          ## 5. 報告
          - 初回応答で取得した <comment_id> のコメントを上書き編集して最終報告を行う
          - 応答: 生成した回答（自然な文章・機械的定型文は避ける）を先頭に"@<github_actor> "を付けてそのまま送信する
          - 例: `jq -n --arg body "@<github_actor> <生成した短い回答>" '{body:$body}' | gh api repos/${REPO_SLUG}/issues/comments/<comment_id> --method PATCH --input -`
          - 調査: 調査範囲・方法・結果・根拠・次の推奨アクションなどを必要に応じて要約して報告
          - 実装: 作業要約、実行コマンドと結果、作成・修正ファイル、エラーと対処、作成したPR番号（該当時）を報告
          - 実行の3.3エラー発生時: エラーの内容、原因予想、解決案、完了タスクと残りのタスクを報告
          - 最終報告はどの分岐でも必ず行われる
          - 終了

          ## =========ユーザーからのプロンプト==========
          ${{ github.event.comment.body || github.event.issue.body || github.event.pull_request.body }}
      run: |
        echo "$PROMPT" | codex exec -c "shell_environment_policy.ignore_default_excludes=true" --dangerously-bypass-approvals-and-sandbox

    - name: Consolidate final response comment
      if: ${{ env.run }}
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        GITHUB_TOKEN: ${{ inputs.github-token }}
        REPO_SLUG: ${{ github.repository }}
        COMMENT_ID: ${{ env.comment }}
        TARGET_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
      run: |
        comment_id="${COMMENT_ID}"
        if [[ -z "$comment_id" ]]; then
          exit 0
        fi

        repo_slug="${REPO_SLUG}"
        ack_body="$(gh api repos/${repo_slug}/issues/comments/${comment_id} --jq '.body' || echo '')"
        if [[ -z "$ack_body" ]]; then
          exit 0
        fi

        # If the acknowledgement already contains final text (not just Thinking...), nothing to do
        if [[ "$ack_body" != Thinking* ]]; then
          exit 0
        fi

        comments_json="$(gh api repos/${repo_slug}/issues/${TARGET_NUMBER}/comments --paginate || echo '[]')"
        latest_entry="$(printf '%s\n' "$comments_json" | jq -r --arg ack "$comment_id" '  [ .[] | select(.user.login == "spikybot") | select((.id|tostring) != $ack) ]  | sort_by(.id) | last // empty')"

        if [[ -z "$latest_entry" || "$latest_entry" == "null" ]]; then
          exit 0
        fi

        latest_id="$(printf '%s' "$latest_entry" | jq -r '.id')"
        latest_body="$(printf '%s' "$latest_entry" | jq -r '.body')"

        if [[ -z "$latest_id" || -z "$latest_body" ]]; then
          exit 0
        fi

        jq -n --arg body "$latest_body" '{body:$body}' \
          | gh api repos/${repo_slug}/issues/comments/${comment_id} --method PATCH -H 'Content-Type: application/json' --input - >/dev/null

        gh api repos/${repo_slug}/issues/comments/${latest_id} --method DELETE >/dev/null
